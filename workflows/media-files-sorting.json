{
  "createdAt": "2025-08-16T20:59:35.336Z",
  "updatedAt": "2025-08-17T16:22:09.000Z",
  "id": "pQazPNrahrBvtWGF",
  "name": "Media files sorting",
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "triggerOn": "folder",
        "path": "/data/video-downloads",
        "events": [
          "add",
          "change",
          "addDir",
          "unlink",
          "unlinkDir"
        ],
        "options": {}
      },
      "type": "n8n-nodes-base.localFileTrigger",
      "typeVersion": 1,
      "position": [
        -832,
        1296
      ],
      "id": "d191c14d-9f78-460d-a9bd-0a2d3a000d7f",
      "name": "Local File Trigger"
    },
    {
      "parameters": {
        "jsCode": "// Filter video files and prepare for processing\nconst videoExtensions = ['.mp4', '.mkv', '.avi', '.mov', '.wmv', '.flv', '.webm', '.m4v', '.ts', '.m2ts'];\nconst items = [];\n\nfor (const item of $input.all()) {\n  const filePath = item.json.path;\n  const fileName = filePath.substring(filePath.lastIndexOf('/') + 1);\n  const extension = fileName.toLowerCase().substring(fileName.lastIndexOf('.'));\n  \n  if (videoExtensions.includes(extension) && !fileName.startsWith('.')) {\n    // Basic episode pattern detection\n    const episodePatterns = [\n      /s\\d{1,2}e\\d{1,2}/i,\n      /season.?\\d{1,2}.?episode.?\\d{1,2}/i,\n      /\\d{1,2}x\\d{1,2}/,\n      /ep\\d{1,2}/i,\n      /episode.?\\d{1,2}/i\n    ];\n    \n    const isLikelyEpisode = episodePatterns.some(pattern => pattern.test(fileName));\n    \n    items.push({\n      originalPath: filePath,\n      originalName: fileName,\n      extension: extension,\n      baseName: fileName.replace(extension, ''),\n      size: item.json.size || 0,\n      isLikelyEpisode: isLikelyEpisode,\n      directory: item.json.directory || item.json.dir || filePath.substring(0, filePath.lastIndexOf('/')) || ''\n    });\n  }\n}\n\nif (items.length === 0) {\n  throw new Error('No video files found in the specified directory');\n}\n\nreturn items;"
      },
      "id": "cd9dfbd9-68f6-4510-8bb1-78b550ae22a4",
      "name": "Filter Video Files & Detect Type",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -608,
        1296
      ]
    },
    {
      "parameters": {
        "model": "gpt-4",
        "options": {
          "temperature": 0.1
        },
        "requestOptions": {}
      },
      "id": "3c11e3bc-63a8-42e3-8918-3794180076c4",
      "name": "OpenAI Media Analysis",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [
        -416,
        1296
      ],
      "credentials": {
        "openAiApi": {
          "id": "JEn1tEMKWXqgk0Y8",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Process OpenAI response and prepare for Telegram with buttons\nconst items = [];\nlet batchNumber = 1;\nconst batchSize = 3;\n\nfor (let i = 0; i < $input.all().length; i += batchSize) {\n  const batch = $input.all().slice(i, i + batchSize);\n  let message = `üé¨ Jellyfin Media Organization - Batch ${batchNumber}\\n\\n`;\n  \n  // Create arrays to store item data for buttons\n  const itemIds = [];\n  const validItems = [];\n  \n  batch.forEach((item, index) => {\n    try {\n      // Parse OpenAI response\n      const aiResponse = JSON.parse(item.json.output.replace(/```json|```/g, '').trim());\n      \n      const globalIndex = i + index + 1;\n      const confidenceIcon = aiResponse.confidence >= 0.8 ? '‚úÖ' : aiResponse.confidence >= 0.6 ? '‚ö†Ô∏è' : '‚ùå';\n      const typeIcon = aiResponse.type === 'movie' ? 'üé¨' : 'üì∫';\n      \n      message += `${globalIndex}Ô∏è‚É£ ${typeIcon} **CURRENT:** \\`${item.json.originalName}\\`\\n`;\n      \n      if (aiResponse.type === 'movie') {\n        message += `   üìÅ **FOLDER:** Movies/${aiResponse.jellyfin_folder}/\\n`;\n        message += `   üé• **FILE:** ${aiResponse.jellyfin_filename.replace('.ext', item.json.extension)}\\n`;\n      } else if (aiResponse.type === 'episode') {\n        message += `   üìÅ **SHOW:** TV Shows/${aiResponse.jellyfin_show_folder}/\\n`;\n        message += `   üìÇ **SEASON:** ${aiResponse.jellyfin_season_folder}/\\n`;\n        \n        // Build episode filename\n        let episodeFilename = `${aiResponse.show_title}`;\n        if (aiResponse.year) episodeFilename += ` (${aiResponse.year})`;\n        episodeFilename += ` - S${String(aiResponse.season).padStart(2, '0')}E${String(aiResponse.episode).padStart(2, '0')}`;\n        if (aiResponse.episode_title) episodeFilename += ` - ${aiResponse.episode_title}`;\n        episodeFilename += item.json.extension;\n        \n        message += `   üì∫ **FILE:** ${episodeFilename}\\n`;\n        aiResponse.final_filename = episodeFilename;\n      }\n      \n      message += `   ${confidenceIcon} **Confidence:** ${Math.round(aiResponse.confidence * 100)}%`;\n      \n      if (aiResponse.quality || aiResponse.source) {\n        message += ` | **Quality:** ${aiResponse.quality || ''} ${aiResponse.source || ''}`.trim();\n      }\n      \n      message += `\\n\\n`;\n      \n      // Store processed data\n      item.json.aiAnalysis = aiResponse;\n      item.json.batchNumber = batchNumber;\n      item.json.itemIndex = globalIndex;\n      \n      // Add to arrays for buttons (only if no error)\n      itemIds.push(globalIndex.toString());\n      validItems.push(item);\n      \n    } catch (error) {\n      message += `${i + index + 1}Ô∏è‚É£ **ERROR:** Could not analyze ${item.json.originalName}\\n   Error: ${error.message}\\n\\n`;\n      item.json.error = error.message;\n      item.json.batchNumber = batchNumber;\n      item.json.itemIndex = i + index + 1;\n    }\n  });\n  \n  // Create inline keyboard with buttons\n  const keyboard = {\n    inline_keyboard: []\n  };\n  \n  // Add individual item buttons (up to 3 per row)\n  if (itemIds.length > 0) {\n    const buttonRows = [];\n    for (let j = 0; j < itemIds.length; j += 3) {\n      const row = itemIds.slice(j, j + 3).map(id => ({\n        text: `‚úÖ ${id}`,\n        callback_data: `approve_${batchNumber}_${id}`\n      }));\n      buttonRows.push(row);\n    }\n    keyboard.inline_keyboard.push(...buttonRows);\n  }\n  \n  // Add action buttons\n  keyboard.inline_keyboard.push([\n    {\n      text: \"‚úÖ Approve All\",\n      callback_data: `approve_all_${batchNumber}`\n    },\n    {\n      text: \"‚è≠Ô∏è Skip Batch\",\n      callback_data: `skip_${batchNumber}`\n    }\n  ]);\n  \n  keyboard.inline_keyboard.push([\n    {\n      text: \"üõë Stop Process\",\n      callback_data: `stop_${batchNumber}`\n    }\n  ]);\n  \n  items.push({\n    batchNumber: batchNumber,\n    message: message,\n    keyboard: keyboard,\n    items: batch,\n    itemIds: itemIds,\n    totalBatches: Math.ceil($input.all().length / batchSize)\n  });\n  \n  batchNumber++;\n}\n\nreturn items;"
      },
      "id": "da838bad-ff90-49e7-bd02-4a4b0e11c1ad",
      "name": "Prepare Telegram Messages",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -80,
        1296
      ]
    },
    {
      "parameters": {
        "chatId": "575184440",
        "text": "={{ $json.message }}",
        "additionalFields": {
          "parse_mode": "Markdown"
        }
      },
      "id": "fc1f5483-a4c2-4b8c-934f-8b842176eb5f",
      "name": "Send to Telegram",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "position": [
        144,
        1296
      ],
      "webhookId": "4a75e3b0-cb46-4a2f-b8e7-82bb46cee737",
      "credentials": {
        "telegramApi": {
          "id": "GquYpMUrgGlWHbny",
          "name": "N8N Bot"
        }
      }
    },
    {
      "parameters": {
        "resume": "webhook",
        "options": {}
      },
      "id": "be1094e0-2978-4773-80c9-907736e5e409",
      "name": "Wait for Approval",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1,
      "position": [
        368,
        1296
      ],
      "webhookId": "wait-for-telegram-response",
      "disabled": true
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "telegram-response",
        "options": {}
      },
      "id": "11b5bb55-597b-40d9-97a0-cf5a2b549512",
      "name": "Telegram Response Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        368,
        1472
      ],
      "webhookId": "bc52f0ac-9e08-4c2f-98f3-dc3387199c65"
    },
    {
      "parameters": {
        "jsCode": "// Process user approval decisions from button callbacks\nconst approvedItems = [];\nconst telegramResponse = $node['Telegram Response Webhook'].json;\nconst batchData = $node['Wait for Approval'].json;\n\n// Handle button callback data\nlet callbackData = '';\nlet chatId = '';\nlet isButtonPress = false;\n\nif (telegramResponse.callback_query) {\n  // Button was pressed\n  callbackData = telegramResponse.callback_query.data;\n  chatId = telegramResponse.callback_query.message.chat.id;\n  isButtonPress = true;\n} else if (telegramResponse.message) {\n  // Fallback for text messages (keep for compatibility)\n  callbackData = telegramResponse.message.text.toLowerCase();\n  chatId = telegramResponse.message.chat.id;\n}\n\n// Parse callback data\nconst parts = callbackData.split('_');\nconst action = parts[0];\nlet batchNumber = batchData.batchNumber;\n\nif (parts.length > 1) {\n  batchNumber = parseInt(parts[1]) || batchData.batchNumber;\n}\n\nif (action === 'stop') {\n  // Send confirmation and stop\n  return [{\n    telegramUpdate: {\n      chatId: chatId,\n      text: 'üõë Process stopped by user. No files were modified.',\n      action: 'stop'\n    }\n  }];\n}\n\nif (action === 'skip') {\n  // Skip this batch, continue to next\n  return [{\n    telegramUpdate: {\n      chatId: chatId,\n      text: '‚è≠Ô∏è Batch skipped. Moving to next batch...',\n      action: 'skip'\n    }\n  }];\n}\n\nif (action === 'approve') {\n  const subAction = parts[1];\n  \n  if (subAction === 'all') {\n    // Approve all items in current batch\n    batchData.items.forEach(item => {\n      if (!item.json.error) {\n        approvedItems.push({\n          ...item.json,\n          approved: true,\n          userDecision: 'all'\n        });\n      }\n    });\n  } else {\n    // Approve specific item\n    const targetBatch = parseInt(parts[1]);\n    const itemIndex = parseInt(parts[2]);\n    \n    batchData.items.forEach(item => {\n      if (!item.json.error && item.json.itemIndex === itemIndex) {\n        approvedItems.push({\n          ...item.json,\n          approved: true,\n          userDecision: 'selected'\n        });\n      }\n    });\n  }\n} else if (!isButtonPress) {\n  // Handle text commands for backwards compatibility\n  if (callbackData === 'all') {\n    batchData.items.forEach(item => {\n      if (!item.json.error) {\n        approvedItems.push({\n          ...item.json,\n          approved: true,\n          userDecision: 'all'\n        });\n      }\n    });\n  } else {\n    // Parse specific numbers\n    const approvedNumbers = callbackData.match(/\\d+/g)?.map(n => parseInt(n)) || [];\n    \n    batchData.items.forEach(item => {\n      if (!item.json.error && approvedNumbers.includes(item.json.itemIndex)) {\n        approvedItems.push({\n          ...item.json,\n          approved: true,\n          userDecision: 'selected'\n        });\n      }\n    });\n  }\n}\n\nif (approvedItems.length === 0) {\n  return [{\n    telegramUpdate: {\n      chatId: chatId,\n      text: 'No items approved in this batch.',\n      action: 'none'\n    }\n  }];\n}\n\n// Add telegram update info to first item\napprovedItems[0].telegramUpdate = {\n  chatId: chatId,\n  text: `‚úÖ ${approvedItems.length} item(s) approved and will be organized.`,\n  action: 'approved'\n};\n\nreturn approvedItems;"
      },
      "id": "be4fc57e-2357-4969-b20b-ad452dc5214d",
      "name": "Process User Approval",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        592,
        1296
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.approved }}",
              "value2": true
            }
          ]
        }
      },
      "id": "bcecae0a-a5e8-4c84-ac15-0e8d1625ed0b",
      "name": "Check if Approved",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        816,
        1296
      ]
    },
    {
      "parameters": {
        "jsCode": "// Create Jellyfin directory structure and organize files\nconst fs = require('fs').promises;\nconst path = require('path');\n\nconst JELLYFIN_BASE_PATH = '/path/to/your/jellyfin';\nconst results = [];\n\nfor (const item of $input.all()) {\n  try {\n    const analysis = item.json.aiAnalysis;\n    let targetPath, folderPath;\n    \n    if (analysis.type === 'movie') {\n      // Movie organization\n      folderPath = path.join(JELLYFIN_BASE_PATH, 'Movies', analysis.jellyfin_folder);\n      const filename = analysis.jellyfin_filename.replace('.ext', item.json.extension);\n      targetPath = path.join(folderPath, filename);\n      \n    } else if (analysis.type === 'episode') {\n      // TV Show organization\n      const showPath = path.join(JELLYFIN_BASE_PATH, 'TV Shows', analysis.jellyfin_show_folder);\n      const seasonPath = path.join(showPath, analysis.jellyfin_season_folder);\n      folderPath = seasonPath;\n      targetPath = path.join(seasonPath, analysis.final_filename);\n    }\n    \n    // Create directory structure\n    await fs.mkdir(folderPath, { recursive: true });\n    \n    // Check if target file already exists\n    try {\n      await fs.access(targetPath);\n      results.push({\n        ...item.json,\n        status: 'skipped',\n        reason: 'File already exists',\n        targetPath: targetPath\n      });\n      continue;\n    } catch {\n      // File doesn't exist, proceed with move\n    }\n    \n    // Move and rename file\n    await fs.rename(item.json.originalPath, targetPath);\n    \n    results.push({\n      ...item.json,\n      status: 'success',\n      oldPath: item.json.originalPath,\n      newPath: targetPath,\n      folderCreated: folderPath,\n      type: analysis.type\n    });\n    \n  } catch (error) {\n    results.push({\n      ...item.json,\n      status: 'error',\n      error: error.message\n    });\n  }\n}\n\nreturn results;"
      },
      "id": "f01cda4b-caff-4f61-89eb-003111d292c1",
      "name": "Organize Files for Jellyfin",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1024,
        1184
      ]
    },
    {
      "parameters": {
        "jsCode": "// Generate completion report\nconst allResults = $input.all();\nconst successful = allResults.filter(r => r.json.status === 'success');\nconst skipped = allResults.filter(r => r.json.status === 'skipped');\nconst errors = allResults.filter(r => r.json.status === 'error');\n\n// Separate by type\nconst movies = successful.filter(r => r.json.aiAnalysis?.type === 'movie');\nconst episodes = successful.filter(r => r.json.aiAnalysis?.type === 'episode');\n\nlet report = `üéâ **Jellyfin Organization Complete!**\\n\\n`;\nreport += `üìä **Summary:**\\n`;\nreport += `üé¨ Movies organized: ${movies.length}\\n`;\nreport += `üì∫ Episodes organized: ${episodes.length}\\n`;\nreport += `‚≠êÔ∏è Skipped (already exist): ${skipped.length}\\n`;\nreport += `‚ùå Errors: ${errors.length}\\n\\n`;\n\nif (movies.length > 0) {\n  report += `**üé¨ Movies Organized:**\\n`;\n  movies.forEach((item, index) => {\n    const movieName = require('path').basename(item.json.newPath);\n    report += `${index + 1}. ${movieName}\\n`;\n  });\n  report += `\\n`;\n}\n\nif (episodes.length > 0) {\n  report += `**üì∫ Episodes Organized:**\\n`;\n  // Group episodes by show\n  const episodesByShow = {};\n  episodes.forEach(item => {\n    const showName = item.json.aiAnalysis.show_title;\n    if (!episodesByShow[showName]) episodesByShow[showName] = [];\n    episodesByShow[showName].push(item);\n  });\n  \n  Object.keys(episodesByShow).forEach(showName => {\n    report += `**${showName}:**\\n`;\n    episodesByShow[showName].forEach(item => {\n      const episodeName = require('path').basename(item.json.newPath);\n      report += `  ‚Ä¢ ${episodeName}\\n`;\n    });\n  });\n  report += `\\n`;\n}\n\nif (errors.length > 0) {\n  report += `**‚ùå Errors:**\\n`;\n  errors.forEach((item, index) => {\n    report += `${index + 1}. ${item.json.originalName}: ${item.json.error}\\n`;\n  });\n  report += `\\n`;\n}\n\nreport += `üé¨üì∫ Don't forget to refresh your Jellyfin libraries!`;\n\nreturn [{ \n  report: report, \n  summary: { \n    movies: movies.length, \n    episodes: episodes.length, \n    skipped: skipped.length, \n    errors: errors.length,\n    total_successful: successful.length\n  } \n}];"
      },
      "id": "10ad6214-fd0b-4a17-ad21-84e5233071e9",
      "name": "Generate Completion Report",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1248,
        1184
      ]
    },
    {
      "parameters": {
        "chatId": "575184440",
        "text": "={{ $json.report }}",
        "additionalFields": {
          "parse_mode": "Markdown"
        }
      },
      "id": "c6add55a-6263-4c40-94c9-af167ca21f3b",
      "name": "Send Final Report",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "position": [
        1472,
        1184
      ],
      "webhookId": "890d37a9-787e-46da-b160-6de855e8e016",
      "credentials": {
        "telegramApi": {
          "id": "GquYpMUrgGlWHbny",
          "name": "N8N Bot"
        }
      }
    },
    {
      "parameters": {
        "url": "http://your-jellyfin-server:8096/Library/Refresh",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "jellyfinApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "id": "5dd3a2ae-8fa3-481b-bb26-edf31854fd6b",
      "name": "Refresh Jellyfin Libraries",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1696,
        1184
      ]
    },
    {
      "parameters": {
        "url": "=https://api.telegram.org/bot{{ $credentials.telegramApi.token }}/answerCallbackQuery",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"callback_query_id\": \"{{ $node['Telegram Response Webhook'].json.callback_query?.id }}\",\n  \"text\": \"‚úÖ Selection processed\"\n}",
        "options": {}
      },
      "id": "df3822e5-d6c9-4342-be84-1743445490cc",
      "name": "Answer Callback Query1",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        592,
        1424
      ]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are a media metadata expert specializing in Jellyfin organization. Analyze this filename for Jellyfin organization: \\\"{{ $json.originalName }}\\\"\\nLikely episode: {{ $json.isLikelyEpisode }}\\nDirectory context: \\\"{{ $json.directory }}\\\"\\n\\nDetermine if this is a MOVIE or TV EPISODE and return ONLY valid JSON:\\n\\n**For Movies:**\\n{\\n  \\\"type\\\": \\\"movie\\\",\\n  \\\"title\\\": \\\"Proper Movie Title\\\",\\n  \\\"year\\\": \\\"YYYY\\\",\\n  \\\"edition\\\": \\\"Director's Cut\\\" or null,\\n  \\\"quality\\\": \\\"4K\\\" or \\\"1080p\\\" or \\\"720p\\\" or null,\\n  \\\"source\\\": \\\"BluRay\\\" or \\\"WEB-DL\\\" or \\\"DVD\\\" or null,\\n  \\\"confidence\\\": 0.95,\\n  \\\"jellyfin_folder\\\": \\\"Movie Title (Year)\\\",\\n  \\\"jellyfin_filename\\\": \\\"Movie Title (Year).ext\\\",\\n  \\\"full_path\\\": \\\"Movies/Movie Title (Year)/Movie Title (Year).ext\\\"\\n}\\n\\n**For TV Episodes:**\\n{\\n  \\\"type\\\": \\\"episode\\\",\\n  \\\"show_title\\\": \\\"Show Name\\\",\\n  \\\"year\\\": \\\"YYYY\\\" or null,\\n  \\\"season\\\": 1,\\n  \\\"episode\\\": 1,\\n  \\\"episode_title\\\": \\\"Episode Name\\\" or null,\\n  \\\"quality\\\": \\\"1080p\\\" or null,\\n  \\\"source\\\": \\\"WEB-DL\\\" or null,\\n  \\\"confidence\\\": 0.95,\\n  \\\"jellyfin_show_folder\\\": \\\"Show Name (Year)\\\",\\n  \\\"jellyfin_season_folder\\\": \\\"Season 01\\\",\\n  \\\"jellyfin_filename\\\": \\\"Show Name (Year) - S01E01 - Episode Title.ext\\\",\\n  \\\"full_path\\\": \\\"TV Shows/Show Name (Year)/Season 01/Show Name (Year) - S01E01.ext\\\"\\n}\\n\\nRules:\\n- Use exact titles from TMDB/TVDb when possible\\n- Extract season/episode numbers accurately\\n- Season folders: 2 digits (Season 01, Season 02)\\n- Episode numbers: 2 digits (S01E01, S02E15)\\n- If episode title unknown, omit from filename\\n- Confidence 0.0-1.0 based on certainty\",",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        -400,
        1584
      ],
      "id": "60bca7a9-f31c-4f4b-a340-c28d1fa3ffb1",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        -544,
        1792
      ],
      "id": "c46d8539-859c-4cdc-a98e-2dfc2611b3fe",
      "name": "OpenRouter Chat Model",
      "credentials": {
        "openRouterApi": {
          "id": "uKb2cRMi6AQKSCn0",
          "name": "OpenRouter account"
        }
      }
    }
  ],
  "connections": {
    "Local File Trigger": {
      "main": [
        [
          {
            "node": "Filter Video Files & Detect Type",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter Video Files & Detect Type": {
      "main": [
        [
          {
            "node": "OpenAI Media Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Media Analysis": {
      "main": [
        [
          {
            "node": "Prepare Telegram Messages",
            "type": "main",
            "index": 0
          },
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Telegram Messages": {
      "main": [
        [
          {
            "node": "Send to Telegram",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send to Telegram": {
      "main": [
        [
          {
            "node": "Wait for Approval",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait for Approval": {
      "main": [
        [
          {
            "node": "Process User Approval",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Telegram Response Webhook": {
      "main": [
        [
          {
            "node": "Process User Approval",
            "type": "main",
            "index": 0
          },
          {
            "node": "Answer Callback Query1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process User Approval": {
      "main": [
        [
          {
            "node": "Check if Approved",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check if Approved": {
      "main": [
        [
          {
            "node": "Organize Files for Jellyfin",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organize Files for Jellyfin": {
      "main": [
        [
          {
            "node": "Generate Completion Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Completion Report": {
      "main": [
        [
          {
            "node": "Send Final Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Final Report": {
      "main": [
        [
          {
            "node": "Refresh Jellyfin Libraries",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "timezone": "Europe/Zurich",
    "callerPolicy": "workflowsFromSameOwner"
  },
  "staticData": null,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "pinData": {},
  "versionId": "0603d26f-1335-46b3-ae9c-eeb57c61aded",
  "triggerCount": 2,
  "tags": []
}